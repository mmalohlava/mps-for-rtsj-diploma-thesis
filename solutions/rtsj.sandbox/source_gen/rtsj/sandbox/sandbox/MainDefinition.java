package rtsj.sandbox.sandbox;

/*Generated by MPS */

import java.util.HashMap;
import javax.realtime.RealtimeThread;
import javax.realtime.MemoryArea;
import javax.realtime.RawMemoryAccess;
import javax.realtime.ImmortalMemory;
import javax.realtime.LTMemory;
import javax.realtime.ScopedMemory;
import javax.realtime.SchedulingParameters;
import javax.realtime.PriorityParameters;
import javax.realtime.MemoryParameters;
import javax.realtime.ProcessingGroupParameters;
import javax.realtime.ReleaseParameters;
import javax.realtime.PeriodicParameters;
import javax.realtime.RelativeTime;
import javax.realtime.NoHeapRealtimeThread;
import javax.realtime.AperiodicParameters;
import java.io.PrintWriter;
import java.io.StringWriter;

public class MainDefinition {
  private static final String WEDGE_THREAD_NAME_SUFFIX = "WedgeThread";
  private static HashMap<String, RealtimeThread> threads = new HashMap<String, RealtimeThread>();
  private static HashMap<String, MemoryArea> memories = new HashMap<String, MemoryArea>();
  private static HashMap<String, RawMemoryAccess> rawMemories = new HashMap<String, RawMemoryAccess>();
  private static HashMap<String, InterThreadChannel> channels = new HashMap<String, InterThreadChannel>();
  private static HashMap<String, ObjectPoolI> objectPools = new HashMap<String, ObjectPoolI>();

  public MainDefinition() {
  }

  public static void main(String[] argc) {

    new Main().run();

    allocateMemory("immortalMemory", ImmortalMemory.instance(), false);
    allocateMemory("ControlRodsMemory", new LTMemory(16, 64), false);
    allocateMemory("PrimaryWaterLoopMemory", new LTMemory(16, 64), false);
    allocateMemory("ReactionSimulatorMemory", new LTMemory(16, 64), false);

    initThreads();
    initChannels();
    initObjectPools();

    runDefaultMode();

    getThread("ReactionSimulator").start();
    getThread("ControlRods").start();
    getThread("PrimaryWaterLoop").start();


    try {
      getThread("ReactionSimulator").join();
      getThread("ControlRods").join();
      getThread("PrimaryWaterLoop").join();
    } catch (InterruptedException e) {
      // ignore 
    }
  }

  public static Object allocateVariable(String memoryName, Class clazz) {
    Object variable = null;
    /*
      try {
        variable = getMemory(memoryName).newInstance(clazz);
      } catch (IllegalAccessException e) {
        killProgram(e);
      } catch (InstantiationException e) {
        killProgram(e);
      }
    */
    return variable;
  }

  public static void allocateMemory(String name, MemoryArea memoryArea, boolean initWedgeThread) {
    if (memories.containsKey(name)) {
      killProgram("MemoryArea with name " + name + " already exists");
    }

    if (initWedgeThread) {
      initWedgeThread(name, (ScopedMemory) memoryArea);
    }

    memories.put(name, memoryArea);
  }

  private static void initWedgeThread(String memoryName, ScopedMemory memory) {
    String name = memoryName + WEDGE_THREAD_NAME_SUFFIX;

    WedgeThread thread = new WedgeThread();
    thread.setMemory(memory);

    threads.put(name, thread);
  }

  public static void startWedgeThread(String memory) {
    String name = memory + WEDGE_THREAD_NAME_SUFFIX;

    if (!(threads.containsKey(name))) {
      killProgram("ScopedMemory " + memory + " has not wedge thread");
    }

    RealtimeThread thread = threads.get(name);
    thread.run();
    try {
      thread.join();
    } catch (InterruptedException e) {
      // ignore 
    }
  }

  public static void stopwedgeThread(String memory) {
    String name = memory + WEDGE_THREAD_NAME_SUFFIX;

    if (!(threads.containsKey(name))) {
      killProgram("ScopedMemory " + memory + " has not wedge thread");
    }

    threads.get(name).interrupt();
  }

  public static void initObjectPools() {
    objectPools.put("objectPool1", new ObjectPooljava_lang_Thread(5, false));
    objectPools.put("objectPool2", new ObjectPooljava_lang_Thread(10, false));
    objectPools.put("objectPoolDouble", new ObjectPooljava_lang_Exception(5, false));
  }

  public static ObjectPoolI getObjectPool(String name) {
    ObjectPoolI objectPool = objectPools.get(name);
    if (objectPool == null) {
      killProgram("ObjectPool " + name + " does not exist.");
    }
    return objectPool;
  }

  public static void freeObjectFromOP(Object object) throws Exception {
    if (object instanceof ObjectPoolElement) {
      ((ObjectPoolElement) object).getObjectPool().free(object);
    } else {
      throw new Exception("Object is not from ObjectPool");
    }
  }

  public static MemoryArea getMemory(String name) {
    MemoryArea memory = memories.get(name);
    if (memory == null) {
      killProgram("MemoryArea " + name + " does not exist.");
    }
    return memory;
  }

  public static void allocateRawMemoryAccess(String name, RawMemoryAccess rawMemoryAccess) {
    rawMemories.put(name, rawMemoryAccess);
  }

  public static RawMemoryAccess getRawMemoryAccess(String name) {
    RawMemoryAccess memory = rawMemories.get(name);
    if (memory == null) {
      killProgram("RawMemory " + name + " does not exist.");
    }
    return memory;
  }

  private static void initThreads() {

    {
      if (threads.containsKey("ReactionSimulator")) {
        killProgram("RealtimeThread with name " + "ReactionSimulator" + " already exists");
      }

      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(2, 0), new RelativeTime(5, 0), new RelativeTime(0, 0), new RelativeTime(5, 0), null, null);

      threads.put("ReactionSimulator", new RealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("ReactionSimulatorMemory"), processingGroupParameters, new CycleWrapperForPerThread(Main.getReactor())));


    }
    {
      if (threads.containsKey("ControlRods")) {
        killProgram("RealtimeThread with name " + "ControlRods" + " already exists");
      }

      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(0, 0), new RelativeTime(8, 0), new RelativeTime(0, 0), new RelativeTime(8, 0), null, null);


      threads.put("ControlRods", new NoHeapRealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("ControlRodsMemory"), processingGroupParameters, Main.getControlRods()));

    }
    {
      if (threads.containsKey("PrimaryWaterLoop")) {
        killProgram("RealtimeThread with name " + "PrimaryWaterLoop" + " already exists");
      }

      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(2, 0), new RelativeTime(5, 0), new RelativeTime(0, 0), new RelativeTime(5, 0), null, null);

      threads.put("PrimaryWaterLoop", new RealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("PrimaryWaterLoopMemory"), processingGroupParameters, new CycleWrapperForPerThread(Main.getWaterLoop())));


    }
  }

  public static RealtimeThread getThread(String name) {
    RealtimeThread thread = threads.get(name);
    if (thread == null) {
      killProgram("RelatimeThread " + name + " does not exist.");
    }
    return thread;
  }

  public static void runDefaultMode() {
    getThread("ControlRods").start();

    try {
      getThread("ControlRods").join();
    } catch (InterruptedException e) {
      // ignore 
    }

    getThread("PrimaryWaterLoop").interrupt();


    getThread("ControlRods").setReleaseParameters(new AperiodicParameters(new RelativeTime(0, 0), new RelativeTime(Long.MAX_VALUE, 999999), null, null));
  }

  public static void initChannels() {
    channels.put("channel1", new ITChannelrtsj_sandbox_sandbox_IntProxy(5));
    channels.put("channel2", new ITChannelrtsj_sandbox_sandbox_IntProxy(5));
  }

  public static InterThreadChannel getChannel(String name) {
    return channels.get(name);
  }

  public static void killProgram(String message) {
    System.err.print(message);
    System.exit(0);
  }

  public static void killProgram(Exception e) {
    System.err.print(getStack(e));
    System.exit(0);
  }

  public static String getStack(Exception e) {
    PrintWriter printWriter = new PrintWriter(new StringWriter());
    e.printStackTrace(printWriter);
    return printWriter.toString();
  }
}
