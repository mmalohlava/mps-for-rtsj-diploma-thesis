package rtsj.sandbox.sandbox;

/*Generated by MPS */

import javax.realtime.NoHeapRealtimeThread;
import javax.realtime.PriorityParameters;
import javax.realtime.PeriodicParameters;
import javax.realtime.RelativeTime;

public class JarTriage {
  public static final double TOLERANCE_FRACTION = 0.02;
  public static final long TRIAGE_THREAD_SCOPE_SIZE_BYTES = 1024 * 100;
  public static final int NUMBER_OF_POOL_THREADS_PER_PRODUCTION_LINE = 10;

  private final AuditLog log;
  /*package*/ JarTriage.TriageRunnable head;
  private WorkerConsole console;
  private volatile boolean stopFlag = false;
  private JarTriage.StopSignal stopSignal = new JarTriage.StopSignal();
  private int maximumNumberOfThreads = 0;
  private int minimumNumberOfThreads = NUMBER_OF_POOL_THREADS_PER_PRODUCTION_LINE;
  private int currentNumberOfThreads = 0;

  public JarTriage(AuditLog log, WorkerConsole console) {
    this.log = log;
    this.console = console;
    initialisePool();
  }

  public void initialisePool() {
    for (int i = 0; i < NUMBER_OF_POOL_THREADS_PER_PRODUCTION_LINE; i++) {
      JarTriage.TriageRunnable r = new JarTriage.TriageRunnable();
      new NoHeapRealtimeThread(new PriorityParameters(PrioritySpecifications.TRIAGE_THREAD_PRIORITY), new PeriodicParameters(new RelativeTime(0, 0), new RelativeTime(0, 0), new RelativeTime(0, 0), new RelativeTime(0, 0), null, null), null, MainDefinition.getMemory("immortalMemory"), null, r).start();
    }
  }

  public void measurementTaken(Measurement m) {
    JarTriage.TriageRunnable threadToUse = null;

    synchronized (this) {
      if (head != null) {
        threadToUse = head;
        head = threadToUse.next;

        currentNumberOfThreads--;

        if (currentNumberOfThreads < minimumNumberOfThreads) {
          minimumNumberOfThreads = currentNumberOfThreads;
        }
      } else {
        minimumNumberOfThreads = 0;
      }
    }

    if (threadToUse != null) {
      threadToUse.giveWork(m);
    } else {
      spawnNewThread(m);
    }
  }

  public void stop() {
    stopFlag = true;

    synchronized (this) {
      while (head != null) {
        synchronized (head) {
          head.notify();
          head = head.next;
        }
      }
    }
  }

  public int getLargestPoolSize() {
    return maximumNumberOfThreads;

  }

  public int getSmallestPoolSize() {
    return minimumNumberOfThreads;
  }

  private void spawnNewThread(Measurement m) {
    JarTriage.TriageRunnable r = new JarTriage.TriageRunnable(m);
    new NoHeapRealtimeThread(new PriorityParameters(5), new PeriodicParameters(new RelativeTime(2, 0), new RelativeTime(5, 0), new RelativeTime(0, 0), new RelativeTime(5, 0), null, null), null, MainDefinition.getMemory("immortalMemory"), null, r).start();
  }

  public class TriageRunnable implements Runnable {
    public JarTriage.TriageRunnable next;
    private Measurement thisMeasurement;

    public TriageRunnable() {
    }

    public TriageRunnable(Measurement m) {
      this.thisMeasurement = m;
    }

    public void run() {
      try {
      } catch (JarTriage.StopSignal e) {
      }
    }

    private void waitForWork() {
      synchronized (this) {
        thisMeasurement = null;
      }

      synchronized (JarTriage.this) {
        this.next = JarTriage.this.head;

        currentNumberOfThreads++;
        if (currentNumberOfThreads > maximumNumberOfThreads) {
          maximumNumberOfThreads = currentNumberOfThreads;
        }
      }

      synchronized (this) {
        while (thisMeasurement == null) {
          if (stopFlag) {
            throw stopSignal;
          }
          try {
            this.wait();
          } catch (InterruptedException e) {
          }
        }
      }
    }

    private void doTriage() {
      if (thisMeasurement == null) {
        return;
      }

      int compResult = compareMeasurmentWithTarget();

      if (compResult > 0) {
        reportOverFilled();
      } else if (compResult == 0) {
        // within tolerance 
      } else {
        reportUnderfilled();
      }
    }

    private void reportUnderfilled() {
      /*
        MainDefinition.getMemory("").enter(new Runnable() {
          public void run() {
            console.jarUnderfilled(thisMeasurement.jarId());
          }
        });
      */
    }

    private void reportOverFilled() {
      /*
        MainDefinition.getMemory("").enter(new Runnable() {
          public void run() {
            console.jarOverfilled(thisMeasurement.jarId());
          }
        });
      */
    }

    private int compareMeasurmentWithTarget() {
      int massOfSweetGrams = thisMeasurement.jarMassGrams() - JarData.massOfJarGrams(thisMeasurement.jarType());

      double numberOfSweets = ((double) massOfSweetGrams) / (SweetData.massOfEachSweetGrams(thisMeasurement.sweetType()));

      int targetNumber = SweetData.targetNumberOfSweetsPerJar(thisMeasurement.sweetType(), thisMeasurement.jarType());

      double difference = numberOfSweets - targetNumber;

      double tolerance = JarTriage.TOLERANCE_FRACTION * targetNumber;

      if (Math.abs(difference) > tolerance) {
        return ((int) Math.signum(difference));
      } else {
        return 0;
      }
    }

    public void giveWork(Measurement m) {
      thisMeasurement = m;
      this.notify();
    }
  }

  private static class StopSignal extends RuntimeException {
    private static final long serialVersionUID = -3295003781208263754L;

    public StopSignal() {
    }
  }
}
