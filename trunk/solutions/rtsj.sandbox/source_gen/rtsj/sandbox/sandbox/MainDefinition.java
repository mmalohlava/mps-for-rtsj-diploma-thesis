package rtsj.sandbox.sandbox;

/*Generated by MPS */

import java.util.HashMap;
import javax.realtime.RealtimeThread;
import javax.realtime.MemoryArea;
import javax.realtime.RawMemoryAccess;
import javax.realtime.ImmortalMemory;
import javax.realtime.LTMemory;
import javax.realtime.SchedulingParameters;
import javax.realtime.PriorityParameters;
import javax.realtime.MemoryParameters;
import javax.realtime.ProcessingGroupParameters;
import javax.realtime.ReleaseParameters;
import javax.realtime.PeriodicParameters;
import javax.realtime.RelativeTime;
import javax.realtime.NoHeapRealtimeThread;
import javax.realtime.AperiodicParameters;
import java.io.PrintWriter;
import java.io.StringWriter;

public class MainDefinition {
  private static HashMap<String, RealtimeThread> threads = new HashMap<String, RealtimeThread>();
  private static HashMap<String, MemoryArea> memories = new HashMap<String, MemoryArea>();
  private static HashMap<String, RawMemoryAccess> rawMemories = new HashMap<String, RawMemoryAccess>();

  public MainDefinition() {
  }

  public static void main(String[] argc) {

    new Main().run();

    MainDefinition.allocateMemory("immortalMemory", ImmortalMemory.instance());
    MainDefinition.allocateMemory("ControlRodsMemory", new LTMemory(16, 64));
    MainDefinition.allocateMemory("PrimaryWaterLoopMemory", new LTMemory(16, 64));
    MainDefinition.allocateMemory("ReactionSimulatorMemory", new LTMemory(16, 64));

    initThreads();

    runDefaultMode();

    getThread("ReactionSimulator").start();
    getThread("ControlRods").start();
    getThread("PrimaryWaterLoop").start();


    try {
      getThread("ReactionSimulator").join();
      getThread("ControlRods").join();
      getThread("PrimaryWaterLoop").join();
    } catch (InterruptedException e) {
      // ignore 
    }
  }

  public static Object allocateVariable(String memoryName, Class clazz) {
    Object variable = null;
    try {
      variable = getMemory(memoryName).newInstance(clazz);
    } catch (IllegalAccessException e) {
      killProgram(e);
    } catch (InstantiationException e) {
      killProgram(e);
    }
    return variable;
  }

  public static void allocateMemory(String name, MemoryArea memoryArea) {
    memories.put(name, memoryArea);
  }

  public static MemoryArea getMemory(String name) {
    MemoryArea memory = memories.get(name);
    if (memory == null) {
      killProgram("MemoryArea " + name + " does not exist.");
    }
    return memory;
  }

  public static void allocateRawMemoryAccess(String name, RawMemoryAccess rawMemoryAccess) {
    rawMemories.put(name, rawMemoryAccess);
  }

  public static RawMemoryAccess getRawMemoryAccess(String name) {
    RawMemoryAccess memory = rawMemories.get(name);
    if (memory == null) {
      killProgram("RawMemory " + name + " does not exist.");
    }
    return memory;
  }

  private static void initThreads() {

    {
      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(2, 0), new RelativeTime(5, 0), new RelativeTime(0, 0), new RelativeTime(5, 0), null, null);

      threads.put("ReactionSimulator", new RealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("ReactionSimulatorMemory"), processingGroupParameters, new CycleWrapperForPerThread(Main.getReactor())));


    }
    {
      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(0, 0), new RelativeTime(8, 0), new RelativeTime(0, 0), new RelativeTime(8, 0), null, null);


      threads.put("ControlRods", new NoHeapRealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("ControlRodsMemory"), processingGroupParameters, Main.getControlRods()));

    }
    {
      SchedulingParameters schedulingParameters = new PriorityParameters(5);
      MemoryParameters memoryParameters = null;
      ProcessingGroupParameters processingGroupParameters = null;
      ReleaseParameters releaseParameters = new PeriodicParameters(new RelativeTime(2, 0), new RelativeTime(5, 0), new RelativeTime(0, 0), new RelativeTime(5, 0), null, null);

      threads.put("PrimaryWaterLoop", new RealtimeThread(schedulingParameters, releaseParameters, memoryParameters, getMemory("PrimaryWaterLoopMemory"), processingGroupParameters, new CycleWrapperForPerThread(Main.getWaterLoop())));


    }
  }

  public static RealtimeThread getThread(String name) {
    RealtimeThread thread = threads.get(name);
    if (thread == null) {
      killProgram("RelatimeThread " + name + " does not exist.");
    }
    return thread;
  }

  public static void runDefaultMode() {
    getThread("ControlRods").start();

    try {
      getThread("ControlRods").join();
    } catch (InterruptedException e) {
      // ignore 
    }

    getThread("PrimaryWaterLoop").interrupt();


    getThread("ControlRods").setReleaseParameters(new AperiodicParameters(new RelativeTime(0, 0), new RelativeTime(Long.MAX_VALUE, 999999), null, null));
  }

  public static void killProgram(String message) {
    System.err.print(message);
    System.exit(0);
  }

  public static void killProgram(Exception e) {
    System.err.print(getStack(e));
    System.exit(0);
  }

  public static String getStack(Exception e) {
    PrintWriter printWriter = new PrintWriter(new StringWriter());
    e.printStackTrace(printWriter);
    return printWriter.toString();
  }
}
